##跟我一起学C++(入门篇)
 * 本课程的几个重要练习
 	
 		1.大整数类
 		2.字符串类
 		3.vector实现
 		4.面向对象版的表达式计算器
 		5.俄罗斯方块的实现

### 01 C++介绍
#### 1.C++值得学习的新特性
* 智能指针如shared_ ptr,weak_ptr等.
* rvalue reference;
* function/bind;
* lambda expression and closure.


### 02 从C到C++
#### 本章目标
* boll类型
* const限定符
* const与#define
* 结构体内存对齐

#### 1.boll类型
* 逻辑型也称布尔型，其取值为true(逻辑真)和false(逻辑假),存储字节数在不同编译系统中可能有所不同，VC++中为1个字节。
* 申明方式：bool result；
* 	result ＝ true；
*  可以当作整数用（true一般为1，false为0）。
*  把其它类型的值转换为布尔值时，非零值转换为true，零值转换为false。

#### 2.const限定符
* 用const给字面常量起个名字（标识符），这个标识符就称为标识符常量；因为标识符常量的申明和使用形式很像变量，所以也称常变量。
* 定义的一般形式：

		const 数据类型 常量名 ＝ 常量值；
		数据类型 const 常量名 ＝ 常量值；
		
* 例如：const float PL = 2.14159f;
* 注意事项：

		常变量在定义时必须初始化；
		常变量初始化之后，不容许再被赋值。
		
#### 3.const与＃define
* const定义的常量与#define定义的符号常量的区别：

		1.const定义的常量有类型，而#define定义的没有类型，编译可以对前者进行类型安全检查，而后者仅仅只是做简单的替换。
		2.const定义的常量在编译时分配内存，而#define定义的常量是在欲编译时进行替换，不分配内存。
		3.作用域不同，const定义的常变量的作用域为该变量的作用域范围。而#define定义的常量作用域为它的定义点到程序结束，当然也可以在某个地方用#undef取消。
		
* 定义常量还可以用enum,尽量用const，enum替换#define定义常量。
* ＃define定义的常量，容易产生副作用。

#### 4.结构体内存对齐
* 什么是内存对齐

		1.编译器为每个“数据单元”安排在在某个合适的位置上。
		2.C＋＋语言非常灵活，它容许你干涉“内存对齐”。
		
* 为什么要对齐

		性能原因：在对齐的地址上访问数据快。
		
* 如何对齐

		1.第一个数据成员放在offset为0的位置。
		2.其它成员对齐至min(sizeof(member), #pragma pack所指定的值)的整数倍。
		3.整个结构体也要对齐，结构体总大小对齐至各个成员中最大对齐数的整数倍。
		
		//第一个成员与结构体变量的偏移量为0
		//其它成员要对齐到某个数字（对齐数）的整数倍的地址
		//对齐数取编译器预设的一个对齐整数与该成员大小的较小值
		//结构体总大小为最大对齐数的整数倍
		

### 03 从C到C++
#### 本章目标
* 域运算符
* new,delete运算符
* 重载
* name managling与extern "C"
* 带默认参数的函数

#### 1.域运算符
 * C++中增加的作用域标识符::

 		* 用于对与局部变量同名的全局变量进行访问
 		* 用于表示类的成员，这将在关于类的一节中详细说明

#### 2.new,delete运算符
* new运算符可以用于创建堆空间
* 成功返回首地址
* 语法：

		指针变量＝new 数据类型;
		指针变量＝new 数据类型［长度n];
		
* 例如：

		int *p; p = new int;
		char *pStr = new char[50];
* delete运算符可以用于释放堆空间
* 语法：

		delete 指针变量；
		delete［］指针变量；
		
* 例如：

		delete p;
		delete []pStr;
		
* new一个新对象

		内存分配(opperator new)
		调用构造函数
		
* delete释放一个对象

		调用析构函数
		释放内存(operator delete)
		
* new用法：

		new operator			分配内存＋调用构造函数
		operator new			只分配内存
		placement new			不分配内存，调用拷贝构造函数

#### 3.重载
*  相同的作用域，如果两个函数名称相同，而参数不同，我们把它们称为重载overload.
*  函数重载又称为函数的多样性
*  函数重载不同形式：

		行参数量不同
		行参类型不同
		行参顺序不同
		行参数量和行参类型都不同
		
* 调用重载函数时，编译器通过检查实际参数的个数，类型和顺序来确定相应的被调用函数。
* 合法的重载例子：

		int abs(int i);
		int abs(long i);
		double abs(double d);
		
* 非法的重载例子：

		int abs(int i);
		long abs(int i);
		void abs(int i);
		//如果返回类型不同而函数名相同，行参也相同，则是不合法的，编译器会报“语法错误”。
		
#### 4.name managling与extern "C"
* name managling这里把它翻译为名字改编。
* C++支持重载，需要进行name managling。
* extern “C”实现C与C++混合编程。
	
		#ifdef __cpluscplus
		extern "C"
		{
		#endif
		...
		#ifdef __cpluscplus
		}
		#endif
	
#### 5.带默认行参值的函数
* 函数申明或者定义的时候，可以给行参赋一些默认值。
* 调用函数时，若没有给出实参，则按指定的默认值进行工作。
* 函数没有声明时，在函数定义中指定行参的默认值。
* 函数既有定义又有声明时，声明时指定后，定义后就不能再指定默认值。
* 默认值的定义必须遵守从右到左的顺序，如果某个行参没有默认值，则它左边的参数就不能有默认值。

		void func1(int a,double b=4.5,int c=3); //合法
		void func2(int a=1,double b,int c=3); //不合法
		
* 函数调用时，实参与行参按从左到右的顺序进行匹配。
* 带默认行参值的函数的二义性

		重载的函数中如果行参带有默认值时，可能产生二义性：
		(例子)
		int add(int x=5,int y=6);
		int add(int x=5,int y=6,int z=7);
		int main(){
			int sum;
			sum = add(10,20);
			return 0;
		}
		
		sum=add(10,20) 语句产生二义性，可以认为该语句是调用第一个函数，也可以是第二个，因此编译器不能确定调用的是哪一个函数。
		
		
### 04 从C到C++
#### 本章目标
* 引用
* const引用
* 引用传递
* 引用作为函数返回值
* 引用与指针区别

#### 1.引用
* 引用是给一个变量起别名。
* 定义引用的一般格式：

		类型 & 引用名 ＝ 变量名；
		例如：int a = 1;
			 int &b = a;
			 //b是a的别名，因此a和b是同一个单元
		注意：定义引用时一定要初始化，指明该引用变量是谁的别名
		
* 在实际应用中，引用一般用作参数传递与返回值。

		1.引用不是变量。
		2.引用仅仅是变量的别名。
		3.引用没有自己独立的空间。
		4.引用要与它所引用的变量共享空间。
		5.对引用所做的改变实际上是对它所引用的变量的改变。
		6.引用在定义的时候要进行初始化。
		7.引用一经初始化，不能重新指向其它变量。
		
* const引用是指指向const对象的引用

		const int ival = 1024;
		const int& refVal = ival;
		int &ref2 = ival;
		
#### 2.按引用传递
* 引用传递方式是在函数定义时在行参前面加上引用运算符“&”（例如：swap(int &a,int &b);）。
* 按值传递方式容易理解，但行参值的改变不能对实参产生影响。
* 地址传递方式通过行参的改变使相应的实参改变，但程序容易产生错误且难以阅读。
* 引用作为参数对行参的任何操作都能改变相应的实参的数据，又使得函数调用显得方便，自然。

#### 3.引用作为返回值
* 引用的另一个作用是用于返回引用的函数。
* 函数返回引用的一个主要目的是可以将函数放在赋值运算符的左边。
* 注意：不能返回对局部变量的引用。

#### 4.引用与指针区别
* 引用访问一个变量是直接访问，而指针是间接访问。
* 引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。
* 引用一经初始化不能再引用其它变量，而指针可以。
* 尽可能使用引用，不得已时使用指针。

		值传递	 		实参要初始化行参数要分配空间，将实参内容拷贝到行参。
		引用传递		实参初始化行参数时不分配空间。
		指针传递		本质是值传递，实参初始化行参的时候，也是要分配空间的，分配的是4个字节的空间（32位系统）如果我们要修改指针的地址，单纯用指针传递是不行的。需 ** 或者 *&
		
		
### 05 从C到C++
#### 本章目标
* 内联函数
* 内联函数与代参数宏的区别
* 新的类型转换运算符

		const_cast<T>(expr)
		static_cast<T>(expr)
		reinterpret_cast<T>(expr)
		dynamic_cast<T>(expr)
	
#### 1.内联函数	
* 当程序执行函数调用时，系统要建立栈空间，保护现场，传递参数以及控制程序执行的转移等等，这些工作需要系统时间和空间的开销。有些情况下，函数本身功能简单，代码很短，但使用频率高，程序频繁调用该函数所花费的时间却很多，从而使得程序执行效率降低。
* 为了提高效率，一个方法就是不使用函数，直接将函数的代码嵌入到程序中。但这个办法也有缺点，一是，相同代码重复书写，而是程序可读性往往没有使用函数的好。
* 为了协调好效率和可读性之间的矛盾，C++提供了另一种方法，即定义内联函数，方法是定义函数时用修饰词inline。

		inline int max(int a,int b)
		{
			return a>b ? a:b;
		}
		
		#define MAX(a,b) (a)>(b)?(a):(b)
		
#### 2.内联函数与带参数宏区别
* 内联函数调用时，要求实参和行参的类型一致，另外内联函数会先对实参表达式进行求值，然后传递给行参；而宏调用时只是简单地替换行参。
* 内联函数是在编译的时候，在调用的地方将代码展开的，而宏则是预处理时进行替换的。
* 在C++中建议采用inline函数来替换参数的宏。

		宏
		
		常量							const enum
		带参数的宏（类似于函数调用）	inline
		
		C++高层次编程	推荐用const，enum,inline替换宏。
		低层次编程		宏还是很灵活的。
		
#### 3.新的类型转换运算符
* 旧式转型：

		(T)expr
		expr(T)
		
*新式转型

		const_cast<T>(expr)
		static_cast<T>(expr)
		reinterpret<T>(expr)

		dynamic_cast<T>(expr)
			*执行“安全向下”转型操作，也就是说支持运行时识别指针或所指向的对象，这事唯一一个无法用旧式语来进行的转型操作。
			
#### 4.const_cast
* 用来移除对象的常量性（cast away the constness）。
* const_cast一般用于指针或者引用。
* 使用const_cast去除const限定的目的不是为了修改它的内容。
* 使用const_cast去除const限定，通常是为了函数能够接受这个实际参数。

#### 5.static_cast
* 编译器隐式执行的任何类型都可以由static_cast完成。
* 当一个较大的算数类型赋值给较小的类型时，可以用static_cast进行强制转换。
* 可以将void＊指针转换为某一类型的指针。
* 可以将基类指针指向派生类指针。
* 无法将const转化为nonconst,这个只有const_cast才可以办得到。			
	
#### 6.reinterpret_cast
* reinterpret_cast“通常为操作数的位模式提供较低层的重新解释”也就是说将数据以二进制存在形式的重新解释。

		int i;
		char *p="This is a example.";
		i = reinterpret_cast<int>(p);
		//此时结果，i与p的值是完全相同的。
		
		int *ip;
		char *pc=reinterpret_cast<char*>(ip);
		//程序员需要记得pc所指向的真实对象是int型，非字符串型。
		//如果将pc当作字符指针进行操作，可能会造成运行时错误。
		//如int len = strlen(pc); 
		
#### 7.尽可能避免强制类型转换
* 尽可能避免使用强制类型转换（显示转换）。
* 如果无法避免，推荐使用新式类型转换。

		隐式转换:编译器可以自动完成的（一般来说是完全的） (int a; short b;   a = b;)。
		显示类型转换:（强制类型转换）。


### 06 面向对象介绍（一）
#### 本章目标
* 程序
* 结构化程序设计
* 面向对象程序设计

#### 1.程序
* 程序：完成一定功能的一系列有序指令集合。

		程序 ＝ 算法 ＋ 数据结构
		按照一定的逻辑来处理这些数据。
		
* 机器语言与汇编语言

		1.机器语言就是一些机器能读懂的二进制指令集合
		2.汇编语言将机器指令映射为一些可以被人读懂的助记符，如ADD,SUB等。
		
* 高级语言

		高级语言屏蔽了机器的细节，提高了语言的抽象层次，程序中可以采取具有一定含义的数据命名和容易理解的执行语句。这使得书写程序时可以联系到程序所描述的具体事物。
		
#### 2.结构化程序设计
* 结构化程序 自顶向下 将系统视为分层的子程序的集合。
* 可以将程序分为功能不同的模块，使得整个程序更有条理性。
* 但很多数据仍然属于整个程序，因而结构化程序设计思想还是需要有很多的全局变量，在某个地方进行更改，所以会对整个程序产生难以预料的影响。


		程序 ＝ 算法 ＋ 数据结构
		按照一定的逻辑来处理这些数据。
	
		例如
		在家就餐
		
		准备菜	：买菜，洗菜，切菜
		烧菜
		上桌就餐
		

* 考虑问题的时候以算法为中心，而不是以数据为中心。
* 要求一个软件负责人，他了解整个系统的任务分解
* 当问题复杂度超过了个人能理清各个子程序之间的调用关系时，这种自顶向下的方法可能失效。
* 传统的程序设计方法可以归纳为“程序＝算法＋数据结构”，将程序定义为处理数据的一系列过程。这个设计方法着眼点是面向过程的，特点是数据与程序分离，即数据与数据处理分离。
* 结构化程序设计的基本思想是采用自顶向下，逐步细化的设计方法和单入单出的控制结构。其理念是将大型程序分解成小型，便于管理的任务。如果其中的一项任务仍然过大，则将它分解为更小的任务。这一过程一直持续下去，直到将程序划分为小型的，易于编写的模块。

#### 3.结构化程序设计的缺点
* 结构化程序设计为处理复杂问题提供了有利手段，但到80年代末，这种设计方法逐渐暴露一下缺点：

		1.程序难以管理。
		2.数据修改存在问题。
		3.程序可重用性差。
		用户难以在系统分析阶段准确定义，致使系统在交付使用时产生许多问题。
		4.用系统开发每个阶段的成果进行控制，不能适应事物变化的要求。
		
* 面向过程程序设计缺点的根源在于数据与数据处理分离。

#### 4.面向对象程序设计
* 面向将系统看成通过交互作用来完成特定功能的对象的集合。每个对象用自己的方法来管理数据。也就是说只有对象内部的代码能够操作对象内部的数据。

		程序 ＝ 对象 ＋对象 ＋对象 ＋ 发送消息
		
		对象 ＝ 算法 ＋ 数据
		
		封装
		
		面向对象的三个特征：
		1.封装
		2.继承
		3.多态
		

### 07 面向对象介绍(二)
#### 本章目标
 * 面向对象程序设计
 * 抽象
 * 封装
 * 继承
 * 多态

#### 1.面向对象程序设计
 * 面向对象是认识事务的一种方法，是一种以对象为中心的思维方式。
 * 面向对象的程序设计：

 		对象 ＝（算法＋数据结构）
 		程序 ＝ 对象 ＋ 对象 ＋ ... ＋ 对象
 		
 * 面向对象程序设计模拟自然界认识和处理事物的方法，将数据和对数据的操作方法放在一起，形成一个相对独立的整体----对象，同类对象还可抽象共性，形成类。一个类中的数据通常只能通过本类提供的方法进行处理，这些方法成为该类与外部的接口。对象之间通过消息进行通讯。

 
#### 2.数据抽象
* 结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。
* 数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。

#### 3.从计算机的观点看对象
* 对象是计算机内存中的一块区域。通过内存分块每个对象在功能上保持独立。
* 这些内存不但存储数据，也存储代码。这保证对象是受保护的，只有对象中的代码能访问存储于对象中的数据。这清楚地限定了对象所具有的功能，并且使得对象不受未知外部事件的影响，从而使自己的数据和功能不会因此遭受破环。
* 对象之间的一个函数被调用时，对象执行内部的代码来相应该调用，从而使对象呈现一定的行为。这个行为及其呈现出来的结果就是该对象所具有的功能。

#### 4.面向对象的基本特征
* 抽象
		
		1.抽象是人们认识事物的一种方法。
		2.抓住事物本质，而不是内部具体细节或具体实现。
		

* 封装

		1.封装是按照信息屏蔽的原则，把对象的属性和操作结合在一起，构成一个独立的对象。
		2.通过限制对属性和操作的权限，可以将属性“隐藏”在对象内部，对外提供一定的接口，在对象之外只能通过接口对对象进行操作。
		3.封装增加了对象的独立性，从而保证了数据的可靠性。
		外部对象不能直接操作对象的属性，只能使用对象提供的服务。

* 继承

		1.继承表达了对象的一般与特殊的关系。特殊类的对象具有一般类的全部属性和服务。
		2.当定义了一个类后，又需要定义一个新类，这个新类与原来的类相比，只是增加或修改了部分属性和操作，这时可以用原来的类派生出新类，新类中只需要描述自己特有的属性和操作。
		3.继承性大大简化了对问题的描述，大大提高了程序的可重用性，从而提高了程序设计，修改，扩充的效率。
		
		对象->类（归类）	从特殊到一般的过程
		大类->小类（分类）	从一般到特殊的过程
* 多态

 		1.多态性：同一个消息被不同对象接收时，产生不同结果，即实现同一接口，不同方法。
 		2.一般类中定义的属性和服务，在特殊类中不改变其名字，但通过各自不同的实现后，可以具有不同的数据类型或具有不同行为。
 		3.多态使得我们能够以一致的观点来看待不同的（但又大相径庭）对象。
 		4.同一消息发送到不同对象，就会呈现出不同行为。
 		
#### 5.继承与多态
* 继承和多态组合，可以生成很多类似但又独一无二的对象。继承性使得这些对象可以共享许多相似特性，而多态又使得同一个操作对不同对象产生不同表现形式。这样不仅提高了程序设计的灵活性，而且减轻了分别设计的负担。

#### 6.面向对象思想总结
* 面向对象是一种认识世界的方法，也是一种程序设计方法。
* 面向对象的观点认为，客观世界是由各种各样的实体，也就是对象组成。每种对象都有自己的内部状态和运动规律。不同对象的相互联系和相互作用就构成了各种不同系统。并进而构成这个客观世界。

#### 7.面向对象编程方法的特性
* 程序设计的重点在数据而不是函数。
* 程序由对象组成，建立对象的目的不是为了完成一个步骤而是为了描述某个事物在整个解决问题步骤中的行为。
* 对象之间通过相互协作来完成功能。
* 函数与相关的数据紧密结合。
* 数据可以被隐藏。
* 很容易扩充新的数据和函数。

		开闭原则：
		对增加开放，对修改和删除关闭。
		
		使用该对象的原有系统就不会发生改变。
		
#### 8.面向对象编程的优缺点
* 面向对象编程优点：(1)易维护；(2)质量高；(3)效率高；(4)易扩展。
* 面向对象编程缺点：运行效率会下降10%左右。


### 08 类与对象（一）
#### 本章目标
* 类声明
* 公有，私有，保护成员
* 数据抽象和封装

#### 1.类声明

	//类是一种用户自定义类型，声明形式：
	class类名称
	{
	public:
			公有成员（外部接口）
	private:
			私有成员
	protected
			保护成员
	}；
	
#### 2.公有，私有，保护成员
* 在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。
* 在关键字private后面声明，只容许本类中的函数访问，而类外部的任何函数都不能访问。
* 在关键字protected后面声明，与private类似，其差别表现在继承与派生时对派生类的影响不同。

#### 3.数据抽象和封装
* 数据抽象是一种依赖于接口和实现分离的编程（和设计）技术。类设计者必须类是如何实现的，但使用该类的程序员不必了解这些细节。使用者只要抽象地考虑该类型做什么，而不必具体地考虑该类如何工作。
* 封装是一项低层次的元素组合起来形成新的，高层次的实体的技术。函数是封装的一种形式：函数所执行的细节行为被封装在函数这个更大的实体中。被封装的元素隐藏了它们的实现细节---可以调用函数，但不能直接访问函数所执行的语句。同样的，类也是一个封装的实体:它代表若干的聚集，设计良好的类隐藏了类实现的细节。


### 09 类与对象（二）
#### 本章目标
* 内联成员函数
* 成员函数的重载及其缺省参数
* 类与结构体
* 隐含的this指针

#### 1.内联函数
* 内联函数：提高效率，编译的时候将代码直接嵌入到调用的地方，从而减少了函数调用的开销。
* 缺点：体积增大，以空间换时间。
* 内联函数仅仅只是给编译器一个提示。如果函数中有switch for,则不会以内敛的方式进行.

#### 2.类与结构体
* class与struct的区别：在未指定访问权限时，class默认的是私有的，struct默认是公有的。

		struct S						class C
		{							  ｛
			int X;//公有的					int X;//私有的
			...							  ...
		}							   }
		
		
#### 3.隐含的this指针
* 成员函数有一个隐含的附加行参，即指向该对象的指针，这个隐含的行参叫做this指针。

		t1.Init(10,20,30); <==> t1.Init(&t1,10,20,30);

* 使用this指针保证了每个对象可以拥有不同的数据成员，但处理这些成员的代码可以被所有对象共享。


### 10 类与对象（三）
#### 本章目标
* 类作用域
* 前向声明
* 嵌套类
* 局部类

#### 1.类作用域
* 每个类都定义了自己的作用域称为类作用域。
* 类作用域中说明的标识符只在类中可见。
* 作用域五种类别：

		1.块作用域
		2.文件作用域
		3.函数原型作用域
		4.函数作用域（只是针对于goto语句来说的）
		5.类作用域
		
#### 2.前向声明
* C++中类必须先定义，才能够实例化。
* 两个类需要相互引用形成一个“环形”引用时，无法先定义使用。这个时候需要用的前向声明。
* 前向声明的类不能实例化。

#### 3.嵌套类
* 外围类需要使用嵌套类对象作为底层实现，并且该嵌套类只用于外围类的实现，且同时可以对用户隐藏该底层实现。
* 从作用域的角度看，嵌套类被隐藏在外围类之中，该类名只能在外围类中使用。如果在外围类的作用域使用该类名时，需要加名字限定。
* 嵌套类中的成员函数可以在它的类体外定义。
* 嵌套类的成员函数对外围类的成员没有访问权，反之亦然。
* 嵌套类仅仅只是语法上的嵌入。

#### 4.局部类
* 类也可以在定义在函数体内，这样的类被称为局部类（local class）。局部类只在定义它的局部域内可见。
* 局部类的成员函数必须被定义在类体中。
* 局部类中不能有静态成员。


### 11 构造函数与析构函数（一）
#### 本章目标
* 构造函数
* 默认构造函数
* 重载构造函数
* 构造函数与new
* 全局对象的构造先于main函数
* 析构造函数
* 析构函数与数组
* 析构函数与delete运算符
* 析构函数可以显示调用

#### 1.构造函数
* 构造函数是特殊的成员函数。
* 创建类类型的新对象，系统会自动调用构造函数。
* 构造函数是为了保证对象的每个数据成员都被正确的初始化。

		1.函数名和类名完全相同。
		2.不能定义构造函数的类型（返回类型），也不能使用void。
		3.通常情况下构造函数应声明为公有函数，否则它不能像其他成员函数那样被显式的调用。
		4.构造函数被声明为私有有特殊的的用途。
		5.构造函数可以有任意类型和任意个数的参数，一个类可以有多个构造函数（重载）。
		
#### 2.默认构造函数
* 不带参数的构造函数。
* 如果程序中未声明，则系统自动产生出一个默认构造函数。

#### 3.析构函数
* 函数名和类名相似（前面多了一个在符“～”）；（～：取反）
* 没有返回值。
* 没有参数。
* 析构函数不能被重载。
* 如果没有定义析构函数，编译器会自动生成一个默认的析构函数，其格式如下：
		
		类名::~默认的析构函数名（）
		｛
			
		｝
		
* 默认的析构函数是一个空函数。


### 12 构造函数与析构函数（二）
####本章目标
* 转换构造函数
* 赋值与初始化区别
* explicit

#### 1.构造函数与析构函数回顾
	 
	 构造函数是一种特殊的成员函数。
	 在创建函数的时候自动调用，对对象的数据成员进行初始化。
	 
	 栈区中创建的对象，在生存期结束的时候自动调用析构函数。
	 在堆上创建的对象，要有程序员显式调用delete释放该对象，同时调用析构函数。
	 全局对象的构造先于main函数。
	 
#### 2.转换构造函数
* 单个参数的构造函数。
* 将其它类型转换为类类型。
* 类的构造函数只有一个参数是非常危险的，因为编译器可以使用这种构造函数把参数的类型隐式转换为类类型。
	
	 构造函数的作用：
	 1.初始化
	 2.类型转换（转换构造函数）
	 
	 带一个参数的构造函数：
	 1.普通构造函数（初始化）
	 2.转换构造函数（初始化、类型转换）
	 
#### 3.赋值与初始化的区别
* 在初始化语句中的等号不是运算符。编译器对这种表示方法有特殊的解释。
* 赋值
* Test& Test::operator=(const Test& other);

#### 4.explicit
* 只提供给类的构造函数使用的关键字。
* 编译器不会把声明为explicit的构造函数用于隐式转换，它只能在程序代码中显示创建对象。


### 13构造函数与析构函数（三）
#### 本章目标
* 构造函数初始化列表
* 对象成员及其初始化列表
* const成员，引用成员初始化

#### 1.构造函数初始化列表
* 推荐在构造函数初始化列表中进行初始化
* 构造函数的执行分为两个阶段

		1.初始化段
		2.普通计算段
		
#### 2.const成员，引用成员初始化
* const成员的初始化只能在构造函数初始化列表中进行。
* 引用成员的初始化也只能在构造函数初始化列表中进行。
* 对象成员（对象所对应的类没有默认构造函数）的初始化，也只能在构造函数初始化列表中进行。 

		class Object		{		public:        Object(int num) : num_(num), kNum_(num), refNum_(num)        {                //kNum_= 100;                //refNum_= num;                cout<<"Object"<<num_<<"..."<<endl;        }        ~Object()        {                cout<<"Obiect..."<<num_<<"..."<<endl;        }		private:        	 int num_;   			 const int kNum_;    	     int& refNum_;		};      ### 14构造函数与析构函数（四）
#### 本章目标
* 拷贝构造函数
* 默认拷贝构造函数
* 拷贝构造函数调用的几种情况

#### 1.拷贝构造函数
* 功能：使用一个已经存在的对象来初始化一个新的统一类型的对象。
* 声明：只有一个参数并且参数为该对象的引用。
* 如果类中没有说明拷贝构造函数，则系统自动生成一个缺省复制构造函数，作为该类的公有成员。

#### 2.拷贝构造函数调用的几种情况
* 当函数的行参是类的对象，调用函数时，进行行参与实参结合时使用。这时要在内部建立一个局部的对象，并把实参拷贝到新的对象中。理所当然也调用拷贝构造函数。
* 当函数的返回值是类的对象，函数执行完成返回调用者时使用。理由也是要建立一个临时对象中，再返回调用者。为什么不直接用要返回的局部对象呢？因为局部对象在离开建立它的函数时就消亡了，不可能在返回调用函数后继续生存，所以在处理这种情况时，编译系统会在调用函数的表达式中建立一个无名临时对象，该临时对象的生存周期只在函数调用处的表达式中，所谓return对象，实际上是调用拷贝构造函数把该对象的值拷入临时对象。如果返回的是变量，处理过程类似，只是不调用构造函数。

### 15构造函数与析构函数（四）
#### 本章目标
* 深拷贝与浅拷贝
* 赋值操作
* 禁止拷贝
* 空类默认产生的成员

#### 1.深拷贝与浅拷贝
* 调用拷贝构造函数，系统默认拷贝构造函数实施的是浅拷贝。
* 调用等号运算符，系统提供的默认等号运算符是浅拷贝。

#### 2.禁止拷贝
* 要让对象是独一无二的，我们要禁止拷贝。
* 方法是将拷贝构造函数与＝运算符声明为私有的，并且不提供它们的实现。

#### 3.空类默认产生的成员
	class Empty{};
	Empty();		//默认的构造函数
	Empty(const Empty&);	//默认的拷贝构造函数
	~Empty();		//默认的析构函数
	Empty& operator=(const Empty&);	//默认的赋值运算符
	Empty* operator&();		//取址运算符
	const Empty* operator&() const;	//取址运算符const
	
* 空类有一个字节。

### 16 对象的使用（一）
#### 本章目标
* static成员
* static成员函数
* 类/对象大小计算

#### 1.static成员
* 对于特定类型的全体对象而言，有时候可能需要访问一个全局变量。比如说统计某种对象已创建的数量。
* 如果我们用全局变量会破坏数据的封装，一般的用户代码都可以修改这个全局变量，这时我们可以用类的静态成员来解决这个问题。
* 非static数据成员存在于类类型的每个对象中，static数据成员独立该类的任意对象存在，它是与类关联的对象，不与类对象关联。
* static成员优点：
		
		1.static成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。
		2.可以实施封装，static成员可以是私有的，而全局对象不可以。
		3.阅读程序容易看出static成员与某个类相关联，这种可见性可以清晰地反映程序员意图。
		
* static成员的定义：static成员需要在类定义外进行初始化与定义。
* 特殊的整型static const成员：整型static const成员可以在类定义中初始化，不需要在类定义体内外进行定义。

#### 2.static成员函数
* static成员函数没有this指针。
* 非静态成员函数可以访问静态成员。
* 静态成员函数不可以访问非静态成员。

#### 3.类对象大小计算
* 类大小计算遵循前面学过的结构体对齐原则。
* 类的大小与数据成员有关与成员函数无关。
* 类的大小与静态数据成员无关。
* 虚函数对类的大小的影响。
* 虚继承对类的影响。


### 17 对象的使用（二）
#### 本章目标
* 四种对象的作用域与生存期
* static用法总结

#### 1.四种对象的作用域与生存期
	1.static成员独立于类对象而存在，也就是说它不属于某个对象的成员，它能被全体对象所共享.
	2.统计类类型对象创建的个数，用static成员来实现。
	3.非static成员它属于类对象，每个对象都有一份拷贝。
	4.static成员函数没有this指针。它不能访问非static成员，也不能调用非static成员函数。
	5.作用域与生存期不等同。

* 栈对象
		
		隐含调用构造函数（程序中没有显示调用）；

* 堆对象

		隐含调用构造函数（程序中没有显示调用）；
	
* 全局对象，静态全局对象

		1.全局对象的构造先于main函数。
		2.已初始化的全局变量或静态全局变量存储于.data段中。
		3.未初始化的全局变量或静态全局对象存储于.bss段中。
		
* 静态局部对象

		1.已初始化的静态局部变量存储于.data段中。
		2.未初始化的静态局部变量存储于.bss段中。
		
#### 2.在C中static用法：
* 1.用于函数内部修饰变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的，比如strtok(3);（信号处理函数）

		void foo()
		{
			static int n = 100;
			//n = 200;
		}
		有状态的
		不可重入函数，不是线程安全的函数

* 2.用在文件级别（函数体之外），修饰变量或函数，表示该变量或函数只在本文件可见，其它文件看不到也访问不到该变量或函数.专业的说法叫“具有internal linkage”(简而言之：不暴露给别的编译单元 translation unit).

			a.c
			static int n = 100;
			b.c
			static int n = 100;			internal linkage
		
			a.c
			int n = 100;			external linkage 全局变量 在.c文件中定义
			b.c
			extern int n;
			
			x.h
			int n = 100;
			a.c 	int n=100;
			b.c 	int n=100;	//重复定义

* C语言的这两种用法很明确，一般也不容易混淆。

#### 3.在C++中static用法总结
* 由于C++引入了类，在保持与C语言兼容的同时，static关键字又有了两种新用法：
* 3.用于修饰类的数据成员，即所谓“静态成员”。这种数据成员的生存期大于class的对象（实例/instance）。静态数据成员是每个class有一份，普通数据成员是每个instance有一份。
* 4.用于修饰class的成员函数，即所谓”静态成员函数“。这种成员函数只能访问静态成员和其他静态成员函数，不能访问非静态成员函数和非静态成员函数。


### 18 对象的使用（三）
#### 本章目标
* static与单例模式

#### 1.static与单例模式
* 保证一个类只有一个实例，并提供一个全局访问点。
* 禁止拷贝。
	
		也可以通过：
		auto_ptr 智能指针
		线程安全的单例模式类的实现
		
### 19 对象的使用（四）
#### 本章目标
* const成员函数
* const对象
* mutable

#### 1.const成员函数
* const成员函数不会修改对象的状态
* const成员函数只能访问数据成员的值，而不能修改它。

#### 2.const对象
* 如果把一个对象指定为const，就是告诉编译器不要修改它。
* const对象的定义：const 类名 对象名（参数表）；
* const对象不能调用非const成员函数。

#### 3.mutable
* 用mutable修饰的数据成员即使在const对象或在const成员函数中都可以被修改。

#### 4.const的用法总结
	const int n = 100;		//定义常量
	const Test t(10);		//定义对象
	
	const int& ref = n;		//const引用
	int& ref = n;				//Error
	
	const与指针：
	const int* p;	//const如果出现在*左边，表示*p是常量（也可以说修饰的是指针所指向的内容）（*p = 200; Error）
	int * const p2;	//const出现在*右边，表示p2是常量(p2 = &n2; Error);
	const int* const* p3 = &n3;//*p3是常量，p3也是常量
	
	1.在类中，如果有const成员，const成员的初始化只能在构造函数初始化列中进行。
	2.const修饰成员函数，表示该成员函数不能修改对象状态，也就是说它只能访问数据成员，但是不能修改数据成员。
	
	
### 20 从一个实例看数据抽象与封装
#### 本章目标
* 用C的方式实现栈
* 用C++的方式实现栈
	
#### 2.C++的方法实现
	(1)避免名称冲突
	(2)类型的扩充
	(3)数据的封装，能够保护内部的数据结构不遭受外界破坏
	
	

### 21 友元
#### 本章目标
* 友元介绍
* 友元函数
* 友元函数注意事项
* 友元类
* 友元类注意事项

#### 1.友元介绍
* 友元是一种允许非成员函数访问类的非公有成员的一种机制。
* 可以把一个函数指定为类的友元，也可把整个类指定为另一个类的友元。

		1.友元函数
		2.友元类
		
#### 2.友元函数
* 友元函数在类作用域外定义，但它需要在类中进行说明。
* 为了与该类的成员函数加以区别，定义的方式是在类中用关键字friend说明该函数，格式如下：

		friend 类型 友元函数名(参数表)
		
* 友元的作用在于提高程序的运行效率。

#### 3.友元函数的注意事项
* 友元函数不是类的成员函数，在函数体中访问对象的成员，必须用对象加运算符“.”，加对象成员名。但友元函数可以访问类中的所有成员(公有的、私有的、保护的),一般函数只能访问类中的公有成员。
* 友元函数不受类中的访问权限关键字限制，可以把它放在公有的、私有、保护部分，但结果一样。
* 某类的友元函数的作用域并非该类的作用域。如果该友元函数是另一类的成员函数，则其作用域为另一类的作用域，否则与一般函数相同。
* 友元函数破坏了面向对象程序设计类的封装性，所有友元函数如果不是必须使用，则尽量少用。或者用其他手段保证封装性。

#### 4.友元类
* 如果某类B的成员函数会频繁的存取另一个类A的数据成员，而A的数据成员的Private/Protect限制造成B存取的麻烦，B只能通过A的Public的成员函数进行间接存钱。
* 把B做成A类的友元类，即A类向B类开发其Private/Protect内容，让B直接存取。
* 友元类：一个类可以作为另一个类的友元。
* 友元类的所有成员函数都是另一个类的友元函数。
* 友元类的声明：friend class 类名；

#### 5.友元类注意事项
* 1.友元关系是单向的
* 2.友元关系不能被传递
* 3.友元关系不能被继承

		1.A是B的友元类(在B中 friend class A),A可以调用B中成员,并不代表B也是A的友元类.
		2.A是B的友元类，B是C的友元类，并不代表A是C的友元类。
		3.A是B的友元类，C继承自A，并不代表C是B的友元。
		
		
### 22 运算符重载（一）
#### 本章目标
* 运算符重载
* 成员函数重载
* 非成员函数重载
* 运算符重载规则

#### 1.运算符重载
* 运算符重载允许把标准运算符(如＋、－、*、／、<、>等)应用于自定义数据类型的对象。
* 直观自然，可以提高程序的可读性。
* 体现了C++的可扩充性。
* 运算符重载仅仅只是语法上的方便，它是另一种函数调用的方式。
* 运算符重载，本质上是函数重载。
* 不要滥用重载、因为它只是语法上的方便，所以只有在涉及的代码更容易写，尤其是更容易读时才有必要重载。

#### 2.成员函数重载
* 成员函数原型的格式：

		函数类型 operator 运算符（参数表）；
		
* 成员函数定义的格式：

		函数类型 类名::operator 运算符（参数表）｛
			函数体；
		｝
#### 3.非成员函数重载
* 友元函数原型的格式：
	
		friend 函数类型 operator 运算符（参数表）；
		
* 友元函数定义的格式：

		friend 函数类型 类名:: operator 运算符（参数表）｛
			函数体；
		｝
		
#### 4.运算符重载的规则
* 运算符重载不允许发明新的运算符。
* 不能改变运算符操作对象的个数。
* 运算符被重载后，其优先级和结合性不会改变。
* 不能重载的运算符：

				运算符						符号
		作用域解析运算符					 ::
		条件运算符						   ?:
		直接成员访问运算符					 .	
		类成员指针引用的运算符					.*
		sizeof运算符						sizeof
		
* 一般情况下，单目运算符最好重载为类的成员函数；双目运算符最好重载为类的友元函数；
* 以下一些双目运算符不能重载为类的友元函数：＝、（）、［］、－>。
* 类型转换运算符只能以成员函数方式重载。
* 流运算符只能以友元的方式重载。


### 23 运算符重载（二）
#### 本章目标
* ++ 运算符重载
* !运算符重载
* 赋值运算符重载

#### 1.++运算符重载
* 1.前置运算符重载:
	
		(1)成员函数的方式重载，原型为：

			函数类型 & operator++();
		
		(2)友元函数的方式重载，原型为：

		friend 函数类型 & operator++(类类型 &);
		
* 2.后置自增和后置自减的重载:

		(1)成员函数的方式重载，原型为：
		
			函数类型 & operator++(int);
			
		(2)友元函数的方式重载，原型为：
		
			friend 函数类型 & operator++(类类型 &,int);
			
#### 2.赋值运算符
	s1 = s2;
	s1.str_ = s2.str_;
	存在当两个对象释放的时候析构函数会将指针所指向的内存释放两次。
	所以也要实施深拷贝。
	
	
### 24 运算符重载（三）
#### 本章目标
* String类实现：
* ［］运算符重载
* ＋运算符重载	(最好重载为友元的方式)
* ＋＝运算符重载
* <<运算符重载
* >>运算符重载

#### 1.[]运算符重载
* const版本和nonconst版本,最好用nonconst版本调用const版本。

#### 2.流运算符重载
* C++的I/O流库的一个重要特性就是能够支持新的数据类型的输出和输入。
* 用户可以通过对插入符（<<）和提取符（>>）进行重载来支持新的数据类型。
* 流运算符的重载只能使用友元函数进行重载。
* 问题：为什么一定要使用友元函数进行重载？
* friend istream& operator>>(istream&,类类型&);
* friend ostream& operator<<(ostream&,类类型&);


### 25 运算符重载（四）
#### 本章目标
* 类型转换运算符
* ->运算符
* operator new、operator delete

#### 1.类型转换运算符
* 必须是成员函数，不能是友元函数。
* 没有参数（操作数是什么）。
* 不能指定返回类型（其实已经指定了）。
* 函数原型：operator 类型名()；

#### 2.operator new、operator delete
* void* operator new(size_t size);
* void operator delete(void* p);
* void operator delete(void* p, size_t size);
* void* operator new(size_t size, const char* file, long line);
* void operator delete(void* p, const char* file, long line);
* void* operator new［］(size_t size);
* void operator delete［］(void* p);
* void operator delete［］(void* p, size_t size);

		new 有三种用法：
		1.new operator	（不能被重载）
		2.operator new	（可以被重载）
		3.placement new	(不分配内存)
		
		
### 26 string_p
####	
	
	标准库的三种类型：
	string		字符串			char*
	vector		动态数组		静态数组［］
	map			key/value		内部是以树的形式存储:算法复杂度O(log2N)，哈析表：算法复杂度O(1)
	
	STL：内存分配器，STL六大组件之一。
	
#### 本章目标
* string介绍
* string对象的定义和初始化
* 常用成员函数

#### 1.标准库string类型
* string类型支持长度可变的字符串，C++标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。
* typedef basic_string<char>string;
* typedef basic_string<wchar_t>wstring;
* 要使用string类型对象，必须包含相关的头文件

		＃include <string>
		using std::string;
		
#### 2.string对象的定义和初始化
* string s1;	//默认构造函数，s1为空串
* string s2(s1);	//将s2初始化为s1的的一个副本
* string s3("value");	//将s3初始化为一个字符串字面值副本
* string s4(n,'c');	// 将s4初始化为字符‘c’的n个副本

		查找帮助(Microsoft Visual Studio) F1键
		
#### 3.常用的成员函数
	成员函数				功能描述
	size()				得到字符串的大小
	length()			 	同上
	empty() 			判断是否为空
	substr()			截取字符串
	find()				在字符串中查找字符或者字符串
	rfind()				反向查找
	replace()			替代
	compare()			比较字符串
	insert()			插入字符
	append()			追加字符
	swap()				交换字符串
	重载运算符			[],+=,=,+,>,<,>=,<=,!=,>>,<<等
	
	
### 27 vector
	
	用string模版类，去除左右空格的实现。

#### 本章目标
* vector介绍
* vector对象初始化
* vector常用成员函数

#### 1.标准库的vector类型
* vector是同一种类型的对象的集合。
* vector的数据结构很像数组，能非常高效和方便地访问单个元素。(动态数组)
* vector是一个类模版（class template）。
* 要使用vector必须包含相关头文件

		＃include <vector>
		using std::vector;
		
#### 2.vector对象的初始化
* vector类定义了好几种构造函数
		
		1.vector<T> v1;
		//vector保存类型为T的对象。默认构造函数v1为空
		2.vector<T> v2(v1);//v2是v1的一个副本
		3.vector<T> v3(n, i);//v3包括n个值为i的元素
		4.vector<T> v4(n);
			//v4含有值初始化的元素的n个副本
			
#### 3.vector成员函数
	
	成员函数					功能描述
	size()					返回元素的个数
	clear()					清除所有元素
	empty()					判断是否为空
	push_back()				在末尾添加一个元素
	pop_back()				删除最后一个元素
	erase()					删除某个元素
	insert()				插入某个元素
	［］						返回元素
	＝						复制副本
	重载运算符				[],=,>,<,>=,<=,!=,==等
	
* string和vector可以将它看成是一种容器，通过迭代器来遍历容器(迭代器可以将它看成是泛型指针)，vector< int >看作int*.

* 六大组件：容器、迭代器、算法、函数对象、适配器、内存分配器。
	
		remove是一个算法需要头文件 ＃include <algorithm>	

### 28 map
	实现如何在vector容器中删除指定元素。
#### 本章目标
* map介绍
* 插入数据
* 查找与修改
* 删除

#### 1.标准库的map类型
* 使用map得包含map类所在的头文件

		#include <map>
		（map实际上是一种关联性容器，基于key,value来存储的
		，内部采用红黑树）
		
* 定义一个map对象

		map<string, int>mapTest;
		//用string作为索引，存储int对象
		
#### 2.插入数据
* mapTest["aaa"] = 100;
* mapTest.insert(map< string,int >::value_type("bbb", 200));
* mapTest.insert(pair<string,int>("ddd", 400));
* mapTest.insert(make_pair<string,int>("ccc", 300));
	
		插入到map容器内部的元素默认是按照key从小到大来排序。
		key类型一定要重载<运算符。

#### 3.查找与修改
* mapTest["aaa"] = 100;
* map<string, int>::iterator it = mapTest.find("aaa");
* it->second = 666;

#### 4.删除
* mapTest.erase("aaa");
* mapTest.erase(it);


### 29 继承（一）
#### 本章目标
* 代码重用
* 继承
* 公有、私有、保护继承
* 默认继承保护级别
* 接口继承与实现继承
* 继承与重定义
* 继承与组合

#### 1.代码重用
* C++很重要的一个特征就是代码重用。在C语言中重用代码的方式就是拷贝代码、修改代码。C++可以用继承或者组合的方式来重用。通过组合或者继承现有的类来创建新类，而不是重新创建它们。
		
		class A
		{
		public:
				void FunA()
				{
					...
				}
		};
		
		组合、将一个类作为另一个类的对象成员。（委托）
		class B
		{
		public:
				void FunB()
				{
					...
				}	
		private:
				A a_;
		};
		
#### 2.继承
* 继承是使自己编写好的类来创建新类，新的类具有原有类的所有属性和操作，也可以在原有类的基础上作一些修改和增补。
* 新类称为派生类或子类，原有类称为基类或者父类。
* 派生类是基类的具体化。
* 派生类的声明语法为：
	
		class派生类名：继承方式 基类名
		｛
			派生类新增成员的声明；
		｝

#### 3.公有、私有、保护成员
* 在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。
* 在关键字private后面声明，只容许本类中的函数访问，而类外部的任何函数都不能访问。
* 在关键字protected后面声明，与private类似，其差别表现在继承与派生时对派生类的影响不同。

#### 4.公有、私有、保护继承
	继承方式	基类成员特性	派生类成员特性	派生类对象访问
	公有继承	public		  public	  可以直接访问
			   protected	protected	 不可直接访问
			   private		不可直接访问	 不可直接访问
	私有继承	public		  private	  不可直接访问
			   protected	 private	 不可直接访问
			   private		不可直接访问   不可直接访问
	保护继承	public		  protected	   不可直接访问
			   protected	 protected	 不可直接访问
			   private		不可直接访问	 不可直接访问
			   
#### 5.默认继承保护级别
* class Base{};
* struct D1 : Base{}; //公有继承
* class D2 : Base{}; //私有继承

#### 6.接口继承与实现继承
* 我们将类的公有成员函数称为接口。
* 公有继承，基类的公有成员函数在派生类中仍然是公有的，换句话说基类的接口成为了派生类的接口，因而将它称为接口继承。
* 实现继承，对于私有、保护继承，派生类不继承基类的接口。派生类将不再支持基类的公有接口，它希望重用基类的实现而已，因而将它称为实现继承。

#### 7.继承与重定义
* 对基类的数据成员的重定义。
* 对基类成员函数的重定义分为两种。
		
		1.overwrite
			(1)与基类完全相同。
			(2)与基类成员函数名相同，参数不同。
		2.override
		
#### 8.继承与组合
* 无论是继承还是组合本质上都是把子对象放在新类型中，两者都是使用构造函数的初始化列表去构造这些子对象。
* 组合是在希望新类内部具有已存在的类的功能时使用，而不是希望已存在类作为它的接口。组合通过嵌入一个对象以实现新类的功能，而新类用户看到的是新定义的接口，而不是来自老类的接口。(has a)
* 如果希望新类与已存在的类有相同的接口(在这基础上可以增加自己的成员)。这时候需要用继承，也称为字类型化。(is a)


### 30继承（二）
#### 本章目标
* 不能自动继承的成员函数
* 继承与构造函数
* 友元关系与继承
* 静态成员与继承

#### 1.不能自动继承的成员函数
* 构造函数
* 析构函数
* ＝运算符

#### 2.继承与构造函数
* 基类的构造函数不被继承，派生类中需要声明自己的构造函数。
* 声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化（调用基类构造函数完成）。
* 派生类的构造函数需要给基类的构造函数传递参数。
	
		（需要在初始化列表中初始化的有，const成员，引用成员，还有下列 第一项）
		1.基类没有默认构造函数的时候，基类的构造函数在派生类构造函数初始化列表中调用。
		2.类的对象成员没有默认构造函数的时候，只能够在类的构造函数初始化列表中调用该对象的构造函数进行初始化。。
		3.先调用基类对象的成员的构造函数，然后调用基类构造函数，再然后是派生类的对象成员的构造函数，最后是派生类自身的构造函数。
				
#### 3.友元关系与继承
* 友元关系不能被继承
* A是B的友元类，C是A的派生类，那么C不是B的友元类。
* 友元关系是单向的。
* 友元关系是不能够被传递的。

#### 4.静态成员与继承
* 静态成员无所谓继承（因为它只有一份拷贝，是共享的）。


### 31继承（三）
#### 本章目标
* 转换与继承
* 派生类到基类的转换
* 基类到派生类的转换

#### 1.转换与继承
* 派生类对象也是基类对象。这意味着在使用基类的地方可以用派生类来替代。

#### 2.派生类到基类的转换
* 派生类以public方式继承基类时，编译器可自动执行的转换(向上转型 upcasting 安全转换)

		1.派生类对象指针自动转化为基类对象指针。将派生类对象看成基类对象。
		2.基类对象指针无法转化为派生类对象指针。无法将基类对象看成是派生类对象。
		3.派生类对象引用自动转化基类对象引用。同（1.）
		4.派生类对象自动转型为基类对象。会产生对象切割(派生类特有的成员消失).object slicing
		
* 当派生类以private/protected方式继承基类时

		1.派生类对象指针(引用)转化为基类对象指针(引用)需用强制类型转换。但不能用static_cast，要用reinterpret_cast。（或者C风格的转换）
		2.不能把派生类对象强制转换为基类对象。
		
* 转型的回顾
		
		1.static_cast 用于编译认可的静态转换。比如从char到int。具有转换构造函数。或者重载了转换构造函数。或者重载了类型转换运算符。
		2.reinterpret_cast 用于编译器不认可的静态准换。从int*转为int 在转型的过程中，不做任何对齐。
		3.const_cast去除常量性。
		4.dynamic_cast用于动态转换。安全的向下转型。多态
		
#### 3.基类到派生类的转换
* 基类对象指针（引用）可用强制类型准换为派生类对象指针(引用)，而基类对象无法执行这类转换。
* 向下转型不安全，没有自动转换的机制。
	
		1.转换构造函数
		将其它类型转换为类类型
		
		cpp中仅从语法上演示基类对象可以转换为派生类对象，但是没有意义。
		
		2.类型转换运算符重载
		将类类型转换为其它类型
		
		
### 32继承（四）
#### 本章目标
* 多重继承
* 虚继承与虚基类
* 虚基类及其派生类构造函数

#### 1.多重继承
* 单继承－－一个派生类最多只能有一个基类。
* 多继承－－一个派生类可以有多个基类。

		1.class 类名：继承方式 基类1，继承方式 基类2,...{};
		2.派生类同时继承多个基类的成员，更好的软件重用。
		3.可能会有大量的二义性，多个基类中可能包含同名变量或函数。
	
* 多重继承中解决访问歧义的方法

		基类名 ::数据成员（或成员函数（参数表））
		* 明确指明要访问定义与哪个基类中的成员。
		
#### 2.虚继承与虚基类
*  当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性－－采用虚基类来解决。
*  虚基类的引入：用于有共同基类的场合。
*  声明：以virtual修饰说明基类：

		例：class B1:virtual public BB
		
* 作用：

		1.主要用来解决多继承时可能发生的对同一基类多次而产生的二义性问题。
		2.为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝。
		
#### 3.虚基类及其派生类构造函数
* 虚基类的成员是由最远的派生类的构造函数通过调用虚基类的构造函数进行初始化的。
* 在整个继承机构中，直接或者间接继承虚基类的所有派生类，都必须在构造函数的成员初始化列表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的默认构造函数。
* 在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。

### 33继承（五）
#### 本章目标
* 虚继承对C＋＋对象内存模型造成的影响
		
		注：对虚基类里面的成员共享，通常将虚基类部分数据成员放在类对象的末尾。
#### 1.类／对象大小计算
* 类大小计算遵循前面学过的结构体对齐原则
* 类的大小与数据成员有关与成员函数无关
* 类的大小与静态数据成员无关
* 虚继承对类的大小的影响
* 虚函数对类的大小的影响

### 2.虚基类表
* virtual base table
		
		1.本类地址与虚基类表指针地址的差（vbtl = 0）
		2.虚基类地址与虚基类表指针地址的差 (vbtl = 8)
		
* virtual base table pointer(vbptr--虚基类表指针)(钻石继承)

		1.virtual的三个意义：存在，共享，间接。
		2.通过指针访问虚基类的成员，需要间接访问，这需要运行时的支持。
		
